<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEDG — Theses</title>
<style>
/* Simple top nav (match your site’s neutral style) */
ul.pages {
  color: blue;
  font-size: 24px;
  list-style-type: none;
  margin: 0; padding: 0;
  overflow: hidden; background-color: #dddddd;
}
li.nav { display: inline; }
li.nav a { display: inline; padding: 2px 2px; text-decoration: none; }
li.nav a:hover { background-color: lightblue; }
.active { background-color: #FFFF00; display: inline; }

/* Layout */
html, body { margin:0; padding:0; font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif; color:#0f172a; background:#f8fafc; }
main { max-width: 1100px; margin: 20px auto 48px; padding: 0 16px; }
h1 { font-weight: 600; margin: 18px 0 8px; }
p.lead { margin: 8px 0 16px; color:#334155; }

/* Filters */
.filters { display:flex; flex-wrap:wrap; gap:10px 12px; align-items:flex-end; margin: 10px 0 10px; }
.field { position:relative; }
label { display:block; font-size:.85rem; color:#475569; margin-bottom:2px; white-space:nowrap; }
input[type="text"], select{
  border:1px solid #cbd5e1; border-radius:10px; padding:8px 28px 8px 10px;
  font-size:.95rem; background:#fff;
}
input[type="text"]{ width:220px; }
select{ width:200px; }
.clear-btn { position:absolute; right:8px; top:50%; transform:translateY(-50%); cursor:pointer; font-weight:700; color:red; font-size:1rem; user-select:none; display:none; }
.field input:not(:placeholder-shown)+.clear-btn,
.field input:focus + .clear-btn { display:block; }

#status { font-size:.9rem; color:#334155; margin-bottom:6px; }
#error { display:none; background:#fef2f2;border:1px solid #fecaca;color:#991b1b;padding:6px 10px;border-radius:8px; margin-bottom:8px; }

/* Year groups + items */
ol#output { list-style:none; padding-left:0; counter-reset:item; }
ol#output > li.group { counter-increment:none; background:transparent; border:none; padding:0; margin:14px 0 4px; font-weight:700; font-size:1.05rem; }
ol#output > li.group::marker { content:''; }
ol#output > li.item {
  counter-increment:item;
  background:#fff; border:1px solid #e2e8f0; border-radius:10px; padding:6px 8px; margin:3px 0;
}
ol#output > li.item::before { content: counter(item) ". "; font-weight:400; margin-right:6px; }
.bib-block { white-space:pre-wrap; background:#f8fafc; border:1px solid #e2e8f0; border-radius:8px; padding:8px; margin-top:6px; font-size:.85rem; }
.bib-btn { margin-left:6px; padding:0 6px; font:inherit; font-size:.85em; color:#444; background:transparent; border:1px solid #cbd5e1; border-radius:6px; cursor:pointer; }
.bib-btn:hover { background:#f1f5f9; }

/* Footer */
footer { max-width: 1100px; margin: 0 auto 36px; padding: 0 16px; color:#334155; }
footer address { font-style: normal; }
</style>
</head>
<body>

<center>
  <ul class="pages">
    <li class="active">Theses</li>
    <li class="nav"><a href="publications.html">Publications</a></li>
    <li class="nav"><a href="index.html">Home</a></li>
  </ul>
</center>

<main>
  <h1>Theses</h1>
  <p class="lead">All theses from MEDG’s BibTeX database, grouped by year (newest first). Titles link to the thesis if a URL or DOI is available.</p>

  <div id="error"></div>

  <div class="filters">
    <div class="field">
      <label for="f-name">Name</label>
      <input id="f-name" type="text" placeholder="e.g., Peter Szolovits" autocomplete="off" spellcheck="false"/>
      <span class="clear-btn" data-target="f-name">☒</span>
    </div>
    <div class="field">
      <label for="f-title">Title</label>
      <input id="f-title" type="text" placeholder="e.g., clinical" autocomplete="off" spellcheck="false"/>
      <span class="clear-btn" data-target="f-title">☒</span>
    </div>
    <div class="field">
      <label for="f-supervisor">Supervisor</label>
      <input id="f-supervisor" type="text" placeholder="e.g., Kohane" autocomplete="off" spellcheck="false"/>
      <span class="clear-btn" data-target="f-supervisor">☒</span>
    </div>
    <div class="field">
      <label for="f-reader">Reader</label>
      <input id="f-reader" type="text" placeholder="e.g., Winston" autocomplete="off" spellcheck="false"/>
      <span class="clear-btn" data-target="f-reader">☒</span>
    </div>
    <div class="field">
      <label for="f-type">Thesis type</label>
      <select id="f-type">
        <option>All</option>
        <option>Doctoral</option>
        <option>Master's</option>
        <option>Bachelor's</option>
        <option>Other</option>
      </select>
    </div>
  </div>

  <div id="status"></div>

  <ol id="output"></ol>
</main>

<footer>
  <hr/>
  <address id="updated">Updated: (loading…)</address>
  <p><a href="http://web.mit.edu/accessibility"><i><b>Accessibility</b></i></a></p>
</footer>

<script>
/* ===== Robust Zotero noise shield (capture + classic onerror) ===== */
(function zoteroShield(){
  function isZoteroNoise(msg, src){
    const blob = String(msg||'') + ' ' + String(src||'');
    return /(Zotero\.Connector|reportActiveURL|inject_safari\.js|safari-extension)/i.test(blob);
  }
  window.addEventListener('error', function(ev){
    if (isZoteroNoise(ev.message, ev.filename)) {
      ev.preventDefault?.(); ev.stopImmediatePropagation?.();
      console.warn('Ignored Zotero extension error (capture):', ev.message);
      return false;
    }
  }, true);
  window.addEventListener('unhandledrejection', function(ev){
    const reason = ev?.reason && (ev.reason.message || String(ev.reason)) || '';
    if (isZoteroNoise(reason, '')) { ev.preventDefault?.(); console.warn('Ignored Zotero extension rejection:', reason); }
  }, true);
  window.onerror = function(message, source){
    if (isZoteroNoise(message, source)) { console.warn('Ignored Zotero extension error (onerror):', message); return true; }
    return false;
  };
})();

/* ======= Helpers ======= */
const $=id=>document.getElementById(id);
const setStatus=html=>{ const e=$('status'); if(e) e.innerHTML=html||''; };
const showError=msg=>{ const e=$('error'); if(e){ e.style.display='block'; e.textContent='⚠️ '+msg; } };
const stripBraces=s=>String(s||'').replace(/[{}]/g,'');
const unlatex=s=>String(s||'').replace(/\\&/g,'&'); // show "\&" as "&"
function escHtml(s){ return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
function escAttr(s){ return String(s).replaceAll('"','&quot;'); }
function fieldClean(s){ return unlatex(stripBraces(s||'')).trim(); }

/* URL params (lenient) */
function getSearchParams() {
  const href = String(window.location.href);
  const qIdx = href.indexOf('?');
  const ampIdx = href.indexOf('&');
  const start = (qIdx >= 0) ? qIdx : (ampIdx >= 0 ? ampIdx : -1);
  if (start >= 0) return new URLSearchParams(href.slice(start + 1));
  return new URLSearchParams('');
}
const getParam=k=>(getSearchParams().get(k)||'').trim();

/* ======= BibTeX fetching/parsing ======= */
const BIB_URL = 'https://mit-medg.github.io/bib/MEDG_theses.bib';
let lastModifiedDate = null;

async function fetchBib(url){
  const res = await fetch(url, {cache:'no-store'});
  if(!res.ok) throw new Error('HTTP '+res.status);
  const lm = res.headers.get('Last-Modified');
  if(lm){
    const d = new Date(lm);
    if(!isNaN(d.getTime())) lastModifiedDate = d;
  }
  return await res.text();
}
function parseBibtex(text){
  text = text.replace(/^\s*%.*$/gm,''); // strip % comments
  const out=[]; const rx=/@([a-zA-Z]+)\s*\{\s*([^,]+)\s*,([\s\S]*?)\}\s*(?=@|$)/g; let m;
  while((m=rx.exec(text))){
    const type=(m[1]||'').toLowerCase();
    const key=(m[2]||'').trim();
    const body=(m[3]||'');
    out.push({type,key,fields:parseFields(body)});
  }
  return out;
}
function parseFields(body){
  const out={}; let i=0, t='', depth=0, inQ=false; const parts=[];
  while(i<body.length){
    const c=body[i];
    if(c=='"' && body[i-1] !== "\\"){ inQ=!inQ; t+=c; i++; continue; }
    if(c=='{' && !inQ){ depth++; t+=c; i++; continue; }
    if(c=='}' && !inQ && depth>0){ depth--; t+=c; i++; continue; }
    if(c==',' && !inQ && depth===0){ parts.push(t); t=''; i++; continue; }
    t+=c; i++;
  }
  if(t.trim()) parts.push(t);
  for(const p of parts){
    const kv=p.split(/\s*=\s*/);
    if(kv.length<2) continue;
    const k=kv.shift().trim().toLowerCase();
    const v=kv.join('=').trim();
    out[k]=unbrace(unquote(v)).replace(/\s+/g,' ').trim();
  }
  return out;
}
const unquote=s=>((s.startsWith('"')&&s.endsWith('"'))||(s.startsWith("'")&&s.endsWith("'")))? s.slice(1,-1):s;
function unbrace(s){
  let changed=true;
  while(changed){
    changed=false;
    if(s.startsWith('{')&&s.endsWith('}')){
      let d=0, ok=true;
      for(let i=0;i<s.length;i++){
        const c=s[i]; if(c=='{') d++; if(c=='}') d--;
        if(d===0 && i<s.length-1){ ok=false; break; }
      }
      if(ok){ s=s.slice(1,-1); changed=true; }
    }
  }
  return s;
}

/* ======= Names & matching ======= */
const splitBibNames=field=>(field||'').split(/\s+and\s+/i).map(s=>s.trim()).filter(Boolean);
function normalizeBibName(name){
  const clean = stripBraces(name).trim();
  if (clean.includes(',')){
    const parts = clean.split(',').map(s=>s.trim());
    if (parts.length === 2) return { last: unlatex(parts[0]), given: unlatex(parts[1]) };
    if (parts.length >= 3){
      const last = (parts[0] + (parts[1] ? ' ' + parts[1] : '')).trim();
      return { last: unlatex(last), given: unlatex(parts.slice(2).join(' ').trim()) };
    }
  }
  const toks = clean.split(/\s+/).filter(Boolean);
  if (toks.length === 1) return { last: unlatex(toks[0]), given: '' };
  const last = toks.pop(), given = toks.join(' ');
  return { last: unlatex(last), given: unlatex(given) };
}
function formatFullName(p){ const last=(p.last||'').trim(), given=(p.given||'').trim(); if(!last) return given; if(!given) return last; return last+', '+given; }

/* Robust, order-/punctuation-agnostic matching with initials support */
function normStr(s){ return String(s||'').toLowerCase().replace(/[{}]/g,'').replace(/[\.,;:()\[\]'"’“”\-]/g,' ').replace(/\s+/g,' ').trim(); }
const tokens=s=>normStr(s).split(/\s+/).filter(Boolean);
function variantsForPerson(p){ const last=normStr(p.last||''), given=normStr(p.given||''); const v1=(given&&last)?(given+' '+last):(given||last); const v2=(last&&given)?(last+' '+given):(last||given); return [v1,v2]; }
function personMatchesTokens(p, qToks){ const vars=variantsForPerson(p).map(normStr); return vars.some(v=>{ const vToks=tokens(v); return qToks.every(qt=>vToks.some(vt=>vt===qt||vt.startsWith(qt))); }); }
function listContainsPerson(field, needle){ if(!needle) return false; const qToks=tokens(needle); if(qToks.length===0) return false; const people=splitBibNames(field).map(normalizeBibName); return people.some(p=>personMatchesTokens(p, qToks)); }

/* ======= Date helpers & sort ======= */
function yearOf(e){ return parseInt((e.fields||{}).year||'0',10)||0; }
function descendingDateScore(e){
  const f=e.fields||{};
  const year=parseInt(f.year||'0',10)||0;
  const mm={jan:1,feb:2,mar:3,apr:4,may:5,jun:6,jul:7,aug:8,sep:9,oct:10,nov:11,dec:12};
  const m=(mm[String(f.month||'').slice(0,3).toLowerCase()] || parseInt(f.month||'0',10) || 0);
  const d=parseInt(f.day||'0',10)||0;
  return (year||0)*10000 + (m||0)*100 + (d||0);
}

/* Month capitalization */
function capMonth(m){
  const s = fieldClean(m);
  if (!s) return '';
  return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
}

/* ======= Classification (prefer TYPE; UAP → bachelors; BS and MEng → masters) ======= */
function thesisKind(fields, btxType){
  const T = String(fields.type || '').toLowerCase();

  // Explicit multi-degree rule → Master's
  if (/\b(bachelor of science\s*(and|&)\s*master of engineering|b\.?s\.?\s*(and|&)\s*m\.?eng\.?)\b/i.test(T)) {
    return 'masters';
  }

  const isDoctoralLike = /\b(phd|scd|sc\.?d|m\.?d)\b/i.test(T);
  const isMastersLike  = /\b(sm|ms|meng|m\.?eng|master|m s\b|s m\b)\b/i.test(T);
  const isBachelorsLike =
    /\b(bachelor|sb|s\.?b\.?|ba|b\.?a\.?|bsc|b\.?sc\.?|uap|undergraduate advanced project|advanced undergraduate project)\b/i.test(T);

  if (isDoctoralLike) return 'doctoral';
  if (isBachelorsLike) return 'bachelors';
  if (isMastersLike)   return 'masters';

  // Fallback to BibTeX entry type only if TYPE missing/ambiguous
  const bt = String(btxType||'').toLowerCase();
  if (bt === 'phdthesis') return 'doctoral';
  if (bt === 'mastersthesis') return 'masters';
  return 'other';
}

/* ======= Type label (display) — add " Thesis" except UAP ======= */
function thesisTypeLabel(fields){
  const raw = (fields.type || '').trim();
  if (!raw) return 'Thesis';
  const t = unlatex(stripBraces(raw));
  if (/\b(undergraduate advanced project|uap)\b/i.test(t)) return t; // no "Thesis" added
  if (/\bthesis\b/i.test(t)) return t;                              // already has Thesis
  return t + ' Thesis';
}

/* ======= Link helpers ======= */
function cleanDoi(s){
  if(!s) return '';
  let x = String(s).trim();
  x = x.replace(/^doi:\s*/i,'');
  x = x.replace(/^https?:\/\/(dx\.)?doi\.org\//i,'');
  x = x.replace(/\s+/g,'');
  x = x.replace(/[<>]/g,'');
  x = x.replace(/\.$/,'');
  return x;
}
function bestLink(fields){
  const doi = cleanDoi(fields.doi||'');
  if(fields.url && fields.url.trim()) return fields.url.trim();
  if(doi) return 'https://doi.org/' + doi;
  return '';
}

/* ======= Vancouver-style thesis rendering ======= */
function formatFullList(field){ const people=splitBibNames(field).map(normalizeBibName); return people.map(formatFullName).join('; '); }
function pluralize(base,n){ return n>1? base+'s' : base; }

function renderThesis(entry){
  const f = entry.fields||{};
  const student = formatFullList(f.author || '');
  const title   = fieldClean(f.title);
  const link    = bestLink(f);
  const school  = fieldClean(f.school || '');
  const dept    = fieldClean(f.department || f.dept || '');
  const city    = fieldClean(f.address || '');
  const month   = capMonth(f.month || '');
  const year    = fieldClean(f.year || '');
  const ttype   = thesisTypeLabel(f);

  const sup = splitBibNames(f.supervisor || f.supervisors || '').map(normalizeBibName);
  const rdr = splitBibNames(f.reader     || f.readers     || '').map(normalizeBibName);

  let s = '';
  if(student) s += escHtml(student) + '. ';
  if(title){
    const titleHtml = link ? ('<a href="'+escAttr(link)+'" target="_blank" rel="noopener noreferrer">'+escHtml(title)+'</a>') : escHtml(title);
    s += titleHtml + '. ';
  }
  if(ttype) s += escHtml(ttype) + ', ';
  if(school) s += escHtml(school);
  if(dept)   s += (school? ', ' : '') + escHtml(dept);
  if(city)   s += (school||dept? ', ' : '') + escHtml(city);
  if(month || year){
    const when = [month, year].filter(Boolean).join(' ');
    s += (when? '. ' + escHtml(when) : '');
  }
  s += '.';

  const parts = [];
  if (sup.length){
    parts.push(pluralize('Supervisor', sup.length) + ': ' + escHtml(sup.map(formatFullName).join('; ')));
  }
  if (rdr.length){
    parts.push(pluralize('Reader', rdr.length) + ': ' + escHtml(rdr.map(formatFullName).join('; ')));
  }
  if(parts.length) s += ' ' + parts.join('. ') + '.';

  if (f.note && String(f.note).trim()){
    s += '<br/>' + escHtml(fieldClean(f.note));
  }

  return s;
}

function buildBibtex(e){
  const omit=/^(date-added|date-modified|bdsk-url.*|file)$/i;
  const lines=['@'+(e.type||'')+'{'+(e.key||'')+','];
  const f=e.fields||{};
  for(const k of Object.keys(f)){
    if(omit.test(k)) continue;
    lines.push('  '+k+' = {'+(f[k]||'')+'},');
  }
  if(lines[lines.length-1].endsWith(',')) lines[lines.length-1]=lines[lines.length-1].slice(0,-1);
  lines.push('}');
  return lines.join('\n');
}

/* ======= Filters ======= */
function matchesName(entry, needle){
  if(!needle) return true;
  const f = entry.fields || {};
  const src = (f.author && f.author.trim()) ? f.author : (f.editor || '');
  return listContainsPerson(src, needle);
}
function matchesSupervisor(entry, needle){
  if(!needle) return true;
  const f = entry.fields || {};
  return listContainsPerson(f.supervisor || f.supervisors || '', needle);
}
function matchesReader(entry, needle){
  if(!needle) return true;
  const f = entry.fields || {};
  return listContainsPerson(f.reader || f.readers || '', needle);
}
function matchesTitle(entry, needle){
  if(!needle) return true;
  const t = fieldClean((entry.fields||{}).title || '');
  return t.toLowerCase().includes(needle.toLowerCase());
}
function matchesType(entry, selected){
  if(!selected || selected==='All') return true;
  const kind = thesisKind(entry.fields||{}, entry.type);
  if(selected==='Doctoral') return kind==='doctoral';
  if(selected==="Master's") return kind==='masters';
  if(selected==="Bachelor's") return kind==='bachelors';
  if(selected==='Other') return !(kind==='doctoral'||kind==='masters'||kind==='bachelors');
  return true;
}

/* ======= Rendering list (group by year, newest first) ======= */
function renderList(entries){
  const out = $('output');
  out.innerHTML = '';
  // group by year
  const map = new Map();
  for(const e of entries){
    const y = yearOf(e) || 0;
    if(!map.has(y)) map.set(y, []);
    map.get(y).push(e);
  }
  const years = Array.from(map.keys()).sort((a,b)=>{
    if(a===0) return 1; if(b===0) return -1; return b - a; // newest first, undated last
  });
  for(const y of years){
    const liG = document.createElement('li');
    liG.className = 'group';
    liG.textContent = (y===0 ? 'No year' : String(y));
    out.appendChild(liG);

    const arr = map.get(y).slice().sort((a,b)=> descendingDateScore(b) - descendingDateScore(a));
    for(const e of arr){
      const li = document.createElement('li');
      li.className = 'item';
      li.innerHTML = renderThesis(e) + ' <button class="bib-btn" type="button">[bib]</button>';
      const btn = li.querySelector('.bib-btn');
      btn.addEventListener('click', ()=>{
        const open = li.querySelector('.bib-block');
        if(open){ open.remove(); return; }
        const pre = document.createElement('div');
        pre.className = 'bib-block';
        pre.textContent = buildBibtex(e);
        li.appendChild(pre);
      });
      out.appendChild(li);
    }
  }
}

/* ======= Main ======= */
(async function(){
  // Prefill from URL (optional)
  const pname  = getParam('name');
  const ptitle = getParam('title');
  const psup   = getParam('supervisor');
  const pread  = getParam('reader');
  const ptype  = getParam('type');

  if(pname)  $('f-name').value = pname;
  if(ptitle) $('f-title').value = ptitle;
  if(psup)   $('f-supervisor').value = psup;
  if(pread)  $('f-reader').value = pread;
  if(ptype)  $('f-type').value = ptype;

  try{
    setStatus('Loading theses …');
    const txt = await fetchBib(BIB_URL);
    const all = parseBibtex(txt).map(e => { e.fields = e.fields||{}; return e; });

    function apply(){
      const nameV  = $('f-name').value.trim();
      const titleV = $('f-title').value.trim();
      const supV   = $('f-supervisor').value.trim();
      const rdrV   = $('f-reader').value.trim();
      const typeV  = $('f-type').value;

      let rows = all.filter(e => e.type==='phdthesis' || e.type==='mastersthesis'); // theses only
      rows = rows.filter(e => matchesType(e, typeV));
      if(nameV)  rows = rows.filter(e => matchesName(e, nameV));
      if(titleV) rows = rows.filter(e => matchesTitle(e, titleV));
      if(supV)   rows = rows.filter(e => matchesSupervisor(e, supV));
      if(rdrV)   rows = rows.filter(e => matchesReader(e, rdrV));

      renderList(rows);
      setStatus(`Loaded ${all.length} entries — showing ${rows.length}` + ((nameV||titleV||supV||rdrV||typeV!=='All')? ' (filters active)' : ''));
    }

    // Wire filters + clear buttons
    ['f-name','f-title','f-supervisor','f-reader','f-type'].forEach(id=>{
      const el = $(id);
      if(!el) return;
      el.addEventListener('input', apply);
      if(el.tagName==='SELECT') el.addEventListener('change', apply);
    });
    document.querySelectorAll('.clear-btn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const id = btn.getAttribute('data-target');
        const el = $(id);
        if(el){ el.value=''; el.dispatchEvent(new Event('input', {bubbles:true})); el.focus(); }
      });
    });

    apply();

    // Footer "Updated:" date (from Last-Modified, fallback to today)
    const updatedEl = $('updated');
    try{
      let d = lastModifiedDate;
      if(!d || isNaN(d.getTime())) d = new Date();
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      if(updatedEl) updatedEl.textContent = `Updated: ${yyyy}-${mm}-${dd}`;
    }catch(_){}
  }catch(e){
    showError(e.message||String(e));
    setStatus('');
    const updatedEl = $('updated');
    if(updatedEl){
      const d=new Date();
      updatedEl.textContent = `Updated: ${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }
  }
})();
</script>
</body>
</html>