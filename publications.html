<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>
<title>MEDG Publications</title>

<link href="https://fonts.googleapis.com/css?family=Crimson+Text:300italic,400italic|Roboto:300,400,300italic,400italic" rel="stylesheet">

<style>
:root { --fg:#0f172a; --muted:#475569; --bg:#f8fafc; --card:#ffffff; }
* { box-sizing: border-box; }
html,body { margin:0; padding:0; background:var(--bg); color:var(--fg);
  font-family:'Source Sans Pro','Helvetica Neue',Helvetica,Arial,sans-serif; }

/* Header + Nav (default) */
#header {
  position: sticky; top:0; z-index:50; display:flex; align-items:center; justify-content:space-between;
  background: rgba(248,250,252,.92); backdrop-filter: saturate(180%) blur(6px);
  border-bottom: 1px solid #e2e8f0; padding: 12px 18px;
}
#brand, #brand a {
  margin:0; font-family:'Roboto','Helvetica Neue',Helvetica,Arial,sans-serif;
  font-weight:300; text-transform:uppercase; letter-spacing:normal; font-size:1.1em;
  color:navy; text-decoration:none;
}
#nav ul { list-style:none; display:flex; gap:22px; margin:0; padding:0; flex-wrap:wrap; }
#nav a {
  display:inline-block; padding:6px 8px; border:none; color:#8a8f98; text-decoration:none;
  font-family:'Roboto','Helvetica Neue',Helvetica,Arial,sans-serif; font-weight:300;
  text-transform:uppercase; letter-spacing:normal; font-size:1em; background:transparent;
}
#nav a:hover { color:#2e2e2e; }

/* Layout */
main { max-width: 1000px; margin: 24px auto; padding: 0 18px 48px; }
.card { background:#fff; border:1px solid #e2e8f0; border-radius:16px; box-shadow:0 2px 10px rgba(2,6,23,.06); padding:18px; }

/* Filters */
.filters { display:flex; flex-wrap:wrap; gap:10px 12px; align-items:flex-end; }
.field { flex:0 0 auto; min-width:0; position:relative; }
label { display:block; font-size:.82rem; color:var(--muted); margin-bottom:2px; white-space:nowrap; }
input[type="text"]{ border:1px solid #cbd5e1; border-radius:10px; padding:8px 28px 8px 10px; font-size:.95rem; width:220px; background:#fff; }
.clear-btn { position:absolute; right:8px; top:50%; transform:translateY(-50%); cursor:pointer; font-weight:700; color:red; font-size:1rem; user-select:none; display:none; }
.field input:not(:placeholder-shown)+.clear-btn,
.field input:focus + .clear-btn { display:block; }
button.reset { border:1px solid #cbd5e1; border-radius:10px; background:#fff; padding:8px 12px; cursor:pointer; }
button.reset:hover { background:#f1f5f9; }

/* Status & Errors */
#status { margin-top:8px; font-size:.9rem; color:#334155; }
#error { margin-top:8px; display:none; background:#fef2f2;border:1px solid #fecaca;color:#991b1b;padding:6px 10px;border-radius:8px; }

/* Output */
#output { list-style:none; padding-left:0; counter-reset:item; margin-top:12px; }
#output li { counter-increment:item; background:#fff; border:1px solid #e2e8f0; border-radius:10px; padding:4px 6px; margin:2px 0; }
#output li::before { content: counter(item) ". "; font-weight:400; margin-right:6px; }
#output li.group { counter-increment:none; background:transparent; border:none; padding:0; margin:10px 0 2px; font-weight:700; font-size:1.05rem; }
#output li.group::before { content:''; margin:0; }

.bib-btn { margin-left:6px; padding:0 6px; font:inherit; font-size:.85em; color:#444; background:transparent; border:1px solid #cbd5e1; border-radius:6px; cursor:pointer; }
.bib-btn:hover { background:#f1f5f9; }
.bib-block { white-space:pre-wrap; background:#f8fafc; border:1px solid #e2e8f0; border-radius:8px; padding:8px; margin-top:6px; font-size:.85rem; }

/* Slots for injected HTML */
#navslot, #headslot, #footslot { margin: 0; padding: 0; }
footer { max-width: 1000px; margin: 24px auto; padding: 0 18px 48px; color:#334155; }
footer address { font-style: normal; color:#334155; }
</style>
</head>
<body>

  <!-- Default header/nav (replaced if ?nav=<url>) -->
  <header id="header">
    <h1 id="brand"><a href="index.html">MIT CSAIL MEDG</a></h1>
    <nav id="nav">
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="people.html">People</a></li>
        <li><a href="https://www.csail.mit.edu/research/clinical-decision-making-group#projects" target="_blank">Projects</a></li>
        <li><a href="publications.html">Publications</a></li>
        <li><a href="theses.html">Theses</a></li>
        <li><a href="blogs.html">Blogs</a></li>
        <li><a href="seminars.html">Seminars</a></li>
        <li><a href="faq.html">FAQs</a></li>
        <li><a href="https://groups.csail.mit.edu/medg/index_archive.html" target="_blank">Archive</a></li>
      </ul>
    </nav>
  </header>

  <!-- Optional nav slot if ?nav=<url> -->
  <div id="navslot"></div>

  <!-- Optional head slot if ?head=<url> -->
  <div id="headslot"></div>

  <main>
    <div class="card">
      <div id="filters" class="filters">
        <div class="field">
          <label for="f-name">Name</label>
          <input id="f-name" type="text" placeholder="e.g., Szolovits, P or Peter Szolovits"
                 autocomplete="off" autocapitalize="off" spellcheck="false" />
          <span class="clear-btn" data-target="f-name">☒</span>
        </div>
        <div class="field">
          <label for="f-title">Title</label>
          <input id="f-title" type="text" placeholder="e.g., learning"
                 autocomplete="off" autocapitalize="off" spellcheck="false" />
          <span class="clear-btn" data-target="f-title">☒</span>
        </div>
        <div class="field">
          <button class="reset" id="btn-reset" type="button">Reset filters</button>
        </div>
      </div>
      <div id="status"></div>
      <div id="error"></div>
    </div>

    <ol id="output"></ol>
  </main>

  <!-- Optional foot slot if ?foot=<url> (appears above the standard footer) -->
  <div id="footslot"></div>

  <footer>
    <hr/>
    <address id="updated">Updated: (loading…)</address>
    <p>
      <a href="http://web.mit.edu/accessibility"><i><b>Accessibility</b></i></a>
    </p>
  </footer>

<script>
/* ================== Ignore extension noise (e.g., Zotero in Safari) ================== */
window.addEventListener('error', function (ev) {
  const src = String(ev.filename || '');
  const msg = String(ev.message || (ev.error && ev.error.message) || '');
  if (/(Zotero\.Connector|inject_safari\.js|safari-extension)/i.test(src + ' ' + msg)) {
    console.warn('Ignored extension error:', src, msg);
    return;
  }
  const el = document.getElementById('error') || document.getElementById('status');
  if (el) { el.style.display = 'block'; el.textContent = '⚠️ ' + (msg || 'Unknown script error'); }
});
window.addEventListener('unhandledrejection', function (ev) {
  const el = document.getElementById('error') || document.getElementById('status');
  if (el) { const reason = ev.reason && (ev.reason.message || ev.reason) || 'Unhandled promise rejection';
    el.style.display = 'block'; el.textContent = '⚠️ ' + reason; }
});

/* ================== DOM & URL helpers ================== */
const $=id=>document.getElementById(id);
const setStatus=html=>{ const e=$('status'); if(e) e.innerHTML = html||''; };
const showError=msg=>{ const e=$('error'); if(e){ e.style.display='block'; e.textContent='⚠️ '+msg; } };
const escHtml=s=>String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
const escAttr=s=>String(s).replaceAll('"','&quot;');
const stripBraces=s=>String(s||'').replace(/[{}]/g,'');
const unlatex=s=>String(s||'').replace(/\\&/g,'&');
const qs=()=>{ try{return new URLSearchParams(window.location.search);}catch(_){return new URLSearchParams('');} };
const getParam=k=>(qs().get(k)||'').trim();

/* Inject external fragment into a target element */
async function injectHtmlFrom(url, targetId){
  try{
    const res = await fetch(url, {cache:'no-store'});
    if(!res.ok) throw new Error('HTTP '+res.status);
    const html = await res.text();
    const el = document.getElementById(targetId);
    if(el){ el.innerHTML = html; }
  }catch(e){ showError('Failed to load '+url+': '+(e.message||e)); }
}

/* ================== Data sources ================== */
const bibFiles = [
  "bib/psz.bib","bib/medg.bib","bib/emily.bib","bib/jindi.bib",
  "bib/mmd.bib","bib/ckbjimmy.bib","bib/stmharry.bib","bib/symin95.bib",
  "bib/gupta.bib","bib/wjl.bib"
];

/* Track last-modified dates to show the latest in footer */
const lastModified = [];

/* ================== Fetch & parse BibTeX ================== */
async function fetchAllBibFiles(files){
  const out = [];
  for(const f of files){
    try{
      const res = await fetch(f, { cache:'no-store' });
      if(!res.ok) throw new Error('HTTP '+res.status);
      const lm = res.headers.get('Last-Modified'); if(lm) lastModified.push(new Date(lm));
      const txt = await res.text();
      out.push({file:f, text:txt});
    }catch(e){ showError('Failed to load '+f+': '+(e.message||e)); }
  }
  return out;
}
function parseBibtex(text){
  text = text.replace(/^\s*%.*$/gm,''); // strip % comments
  const out=[]; const rx=/@([a-zA-Z]+)\s*\{\s*([^,]+)\s*,([\s\S]*?)\}\s*(?=@|$)/g; let m;
  while((m=rx.exec(text))){
    const type=(m[1]||'').toLowerCase();
    const key=(m[2]||'').trim();
    const body=(m[3]||'');
    out.push({type,key,fields:parseFields(body)});
  }
  return out;
}
function parseFields(body){
  const out={}; let i=0, t='', depth=0, inQ=false; const parts=[];
  while(i<body.length){
    const c=body[i];
    if(c=='"' && body[i-1] !== "\\"){ inQ=!inQ; t+=c; i++; continue; }
    if(c=='{' && !inQ){ depth++; t+=c; i++; continue; }
    if(c=='}' && !inQ && depth>0){ depth--; t+=c; i++; continue; }
    if(c==',' && !inQ && depth===0){ parts.push(t); t=''; i++; continue; }
    t+=c; i++;
  }
  if(t.trim()) parts.push(t);
  for(const p of parts){
    const kv=p.split(/\s*=\s*/);
    if(kv.length<2) continue;
    const k=kv.shift().trim().toLowerCase();
    const v=kv.join('=').trim();
    out[k]=unbrace(unquote(v)).replace(/\s+/g,' ').trim();
  }
  return out;
}
const unquote=s=>((s.startsWith('"')&&s.endsWith('"'))||(s.startsWith("'")&&s.endsWith("'")))? s.slice(1,-1):s;
function unbrace(s){
  let changed=true;
  while(changed){
    changed=false;
    if(s.startsWith('{')&&s.endsWith('}')){
      let d=0, ok=true;
      for(let i=0;i<s.length;i++){
        const c=s[i]; if(c=='{') d++; if(c=='}') d--;
        if(d===0 && i<s.length-1){ ok=false; break; }
      }
      if(ok){ s=s.slice(1,-1); changed=true; }
    }
  }
  return s;
}

/* ================== Date & link helpers ================== */
function cleanDoi(s){
  if(!s) return '';
  let x = String(s).trim();
  x = x.replace(/^doi:\s*/i,'');
  x = x.replace(/^https?:\/\/(dx\.)?doi\.org\//i,'');
  x = x.replace(/\s+/g,'');
  x = x.replace(/[<>]/g,'');
  x = x.replace(/\.$/,'');
  return x;
}
function bestLink(fields){
  const doi = cleanDoi(fields.doi||'');
  if(fields.url && fields.url.trim()) return fields.url.trim();
  if(doi) return 'https://doi.org/' + doi;
  return '';
}
const yearOf=e=>parseInt((e.fields||{}).year||'0',10)||0;
function descendingDateScore(e){
  const f=e.fields||{};
  const year=parseInt(f.year||'0',10)||0;
  const mm={jan:1,feb:2,mar:3,apr:4,may:5,jun:6,jul:7,aug:8,sep:9,oct:10,nov:11,dec:12};
  const m=(mm[String(f.month||'').slice(0,3).toLowerCase()] || parseInt(f.month||'0',10) || 0);
  const d=parseInt(f.day||'0',10)||0;
  return year*10000 + m*100 + d;
}

/* ================== Name normalization & matching ================== */
const splitBibNames=field=>(field||'').split(/\s+and\s+/i).map(s=>s.trim()).filter(Boolean);
function normalizeBibName(name){
  const clean = stripBraces(name).trim();
  if (clean.includes(',')){
    const parts = clean.split(',').map(s=>s.trim());
    if (parts.length === 2) return { last: unlatex(parts[0]), given: unlatex(parts[1]) };
    if (parts.length >= 3){
      const last = (parts[0] + (parts[1] ? ' ' + parts[1] : '')).trim();
      return { last: unlatex(last), given: unlatex(parts.slice(2).join(' ').trim()) };
    }
  }
  const toks = clean.split(/\s+/).filter(Boolean);
  if (toks.length === 1) return { last: unlatex(toks[0]), given: '' };
  const last = toks.pop(), given = toks.join(' ');
  return { last: unlatex(last), given: unlatex(given) };
}
function givenToInitials(given){
  if(!given) return '';
  return given.split(/\s+/).filter(Boolean).map(w=>{
    return w.split('-').map(p=>p[0]? (p[0].toUpperCase()+'.') : '').join('-');
  }).join(' ');
}
function formatNameVancouver(p){
  const last = (p.last||'').trim();
  const given = (p.given||'').trim();
  const inits = givenToInitials(given);
  if(!last) return inits || '';
  if(!inits) return last;
  return last + ' ' + inits;
}
/* robust, order-agnostic matching (supports initials) */
function normStr(s){
  return String(s||'')
    .toLowerCase()
    .replace(/[{}]/g,'')
    .replace(/[\.,;:()\[\]'"’“”\-]/g,' ')
    .replace(/\s+/g,' ')
    .trim();
}

/* ---------- Vancouver author formatter (initials, no truncation) ---------- */
/* Usage: formatAuthors(f.author || '', true) */

function formatAuthors(nameField, useInitials = true){
  const raw = String(nameField || '').trim();
  if (!raw) return '';

  // Local fallbacks in case these helpers aren't defined in this file
  const _stripBraces = s => String(s||'').replace(/[{}]/g,'');
  const _unlatex     = s => String(s||'').replace(/\\&/g,'&');
  const _clean       = s => _unlatex(_stripBraces(s||'')).trim();

  const splitBibNames = field =>
    String(field||'')
      .split(/\s+and\s+/i)
      .map(s => s.trim())
      .filter(Boolean);

  // Parse BibTeX names:
  //  - "Last, First Middle" (optionally with particles/jr)
  //  - or "First Middle Last"
  function normalizeBibName(name){
    const n = _clean(name);
    if (!n) return { last:'', given:'' };

    if (n.includes(',')){
      // "Last, First Middle [Jr]"  (collapse anything after the first comma into given)
      const parts = n.split(',').map(s => s.trim());
      const last  = parts[0] || '';
      const given = parts.slice(1).join(' ').trim();
      return { last, given };
    } else {
      // "First Middle Last"
      const toks = n.split(/\s+/).filter(Boolean);
      if (toks.length === 1) return { last: toks[0], given: '' };
      const last  = toks.pop();
      const given = toks.join(' ');
      return { last, given };
    }
  }

  function givenToInitials(given){
    if (!given) return '';
    return given
      .split(/\s+/)
      .filter(Boolean)
      .map(w =>
        w.split('-')
         .map(p => p ? (p[0].toUpperCase() + '.') : '')
         .join('-')
      )
      .join(' ');
  }

  const people = splitBibNames(raw).map(normalizeBibName);
  const rendered = people.map(p => {
    const last  = _clean(p.last);
    const given = _clean(p.given);
    if (!last && !given) return '';
    if (useInitials) {
      const init = givenToInitials(given);
      return last ? (init ? `${last} ${init}` : last) : init; // Vancouver: Last F. M.
    } else {
      return last ? (given ? `${last}, ${given}` : last) : given; // not used for pubs, kept for completeness
    }
  }).filter(Boolean);

  // Vancouver: authors separated by ", " (no ampersand)
  return rendered.join(', ');
}

const tokens=s=>normStr(s).split(/\s+/).filter(Boolean);
const normalizedPeople=field=>splitBibNames(field).map(p => normalizeBibName(p));
function variantsForPerson(p){
  const last  = normStr(p.last||'');
  const given = normStr(p.given||'');
  const v1 = (given && last) ? (given + ' ' + last) : (given || last);
  const v2 = (last  && given)? (last  + ' ' + given): (last  || given);
  return [v1, v2];
}
function personMatchesTokens(p, qToks){
  const variants = variantsForPerson(p).map(normStr);
  return variants.some(v => {
    const vToks = tokens(v);
    return qToks.every(qt => vToks.some(vt => (vt === qt) || vt.startsWith(qt)));
  });
}
function peopleListMatchesEntry(entry, needle){
  if(!needle) return true;
  const f = entry.fields || {};
  const src = (f.author && f.author.trim()) ? f.author : (f.editor || '');
  if(!src) return false;
  const qToks = tokens(needle);
  if(qToks.length === 0) return true;
  const people = normalizedPeople(src);
  return people.some(p => personMatchesTokens(p, qToks));
}

/* ================== Deduplication by key ================== */
function dedupeByKey(entries){
  const byKey = new Map();
  const srcSet = new Map();
  for(const e of entries){
    const k = String(e.key||'').toLowerCase();
    if(!k) continue;
    if(!byKey.has(k)){
      const clone = { ...e, fields: { ...(e.fields||{}) }, _srcFiles: [e._src] };
      byKey.set(k, clone);
      srcSet.set(k, new Set([e._src]));
    }else{
      const base = byKey.get(k);
      const f = e.fields || {};
      for(const name of Object.keys(f)){
        if(base.fields[name] == null || base.fields[name] === ''){
          base.fields[name] = f[name];
        }
      }
      const set = srcSet.get(k);
      set.add(e._src);
      base._srcFiles = Array.from(set);
    }
  }
  return Array.from(byKey.values());
}

/* ================== Rendering (Vancouver) ================== */
const fieldClean=s=>unlatex(stripBraces(s||'')).trim();

function formatAuthorsNonThesis(f){
  const src = (f.author && f.author.trim()) ? f.author : (f.editor || '');
  if(!src) return '';
  const people = normalizedPeople(src);
  const names = people.map(formatNameVancouver);
  if(f.author && !f.editor) return names.join(', ') + '.';
  if(f.editor && !f.author){
    const cnt = people.length;
    return names.join(', ') + (cnt>1? ' (editors).' : ' (editor).');
  }
  return names.join(', ') + '.';
}
function vancouverGeneric(entry){
  const f = entry.fields || {};
  const authors = formatAuthorsNonThesis(f);
  const title = fieldClean(f.title);
  const link = bestLink(f);
  const titleHtml = title ? (link ? ('<a href="'+escAttr(link)+'" target="_blank" rel="noopener noreferrer">'+escHtml(title)+'</a>')
                                  : escHtml(title)) : '';

  const j = fieldClean(f.journal || f.booktitle || f.series || '');
  const vol = fieldClean(f.volume);
  const no = fieldClean(f.number);
  const pages = fieldClean(f.pages);
  const year = fieldClean(f.year);

  let out = '';
  if(authors) out += escHtml(authors)+' ';
  if(titleHtml) out += titleHtml + '. ';
  if(j) out += '<em>'+escHtml(j)+'</em>';
  if(vol) out += ' '+escHtml(vol);
  if(no) out += '('+escHtml(no)+')';
  if(pages) out += ':'+escHtml(pages);
  if(year) out += ' ('+escHtml(year)+')';
  out += '.';
  return out;
}
function vancouverInBook(entry){
  const f = entry.fields||{};
  const authors = formatAuthorsNonThesis(f);
  const title = fieldClean(f.title);
  const link = bestLink(f);
  const titleHtml = title ? (link ? ('<a href="'+escAttr(link)+'" target="_blank" rel="noopener noreferrer">'+escHtml(title)+'</a>')
                                  : escHtml(title)) : '';

  const bookAuthor = fieldClean(f.bookauthor);
  const editor = fieldClean(f.editor);
  const booktitle = fieldClean(f.booktitle);
  const whereNames = bookAuthor ? bookAuthor : (editor ? (editor + (splitBibNames(f.editor).length>1?' (eds.)':' (ed.)')) : '');
  const j = [whereNames, booktitle].filter(Boolean).join(', ');

  const vol = fieldClean(f.volume);
  const no = fieldClean(f.number);
  const pages = fieldClean(f.pages);
  const year = fieldClean(f.year);

  let out = '';
  if(authors) out += escHtml(authors)+' ';
  if(titleHtml) out += titleHtml + '. ';
  if(j) out += '<em>'+escHtml(j)+'</em>';
  if(vol) out += ' '+escHtml(vol);
  if(no) out += '('+escHtml(no)+')';
  if(pages) out += ':'+escHtml(pages);
  if(year) out += ' ('+escHtml(year)+')';
  out += '.';
  return out;
}
function renderItem(li, entry){
  const type = (entry.type||'').toLowerCase();
  if (entry.type === 'techreport') {
    return renderTechReport(entry);
  }
  const html = (type==='inbook' || type==='incollection') ? vancouverInBook(entry) : vancouverGeneric(entry);
  li.innerHTML = html + ' <button class="bib-btn" type="button">[bib]</button>';
  const btn = li.querySelector('.bib-btn');
  btn.addEventListener('click', function(){
    const open = li.querySelector('.bib-block');
    if(open){ open.remove(); return; } // toggle
    const pre = document.createElement('div');
    pre.className = 'bib-block';
    pre.textContent = filteredBibText(entry);
    li.appendChild(pre);
  });
}

function renderTechReport(entry){
  const f = entry.fields || {};
  const authors = formatAuthors(f.author || '', /*useInitials=*/true);
  // initials for non-theses
  if (!authors && f.editor) authors = formatAuthors(f.editor, true) + ' (eds.)';)
  const title   = fieldClean(f.title);
  const link    = bestLink(f);
  const year    = fieldClean(f.year || '');
  const inst    = fieldClean(f.institution || f.organization || '');
  const trType  = fieldClean(f.type || 'Technical Report'); // use BibTeX 'type' when present
  const num     = fieldClean(f.number || '');

  let s = '';
  if (authors) s += escHtml(authors) + '. ';
  if (title){
    const t = escHtml(title);
    s += link ? `<a href="${escAttr(link)}" target="_blank" rel="noopener noreferrer">${t}</a>. `
              : `${t}. `;
  }

  // Build the "type, No. X, Institution" block
  const parts = [];
  if (trType) parts.push(escHtml(trType));
  if (num)    parts.push('No. ' + escHtml(num));
  if (inst)   parts.push(escHtml(inst));
  if (parts.length) s += parts.join(', ') + '. ';

  if (year) s += escHtml(year) + '.';

  return s.trim();
}

function filteredBibText(e){
  const omit = /^(date-added|date-modified|bdsk-url.*|file)$/i;
  const lines = [];
  lines.push('@'+(e.type||'')+'{'+(e.key||'')+',');
  const f = e.fields||{};
  const keys = Object.keys(f);
  for(const k of keys){
    if(omit.test(k)) continue;
    lines.push('  '+k+' = {'+(f[k]||'')+'},');
  }
  if(lines[lines.length-1].endsWith(',')){
    lines[lines.length-1] = lines[lines.length-1].slice(0,-1);
  }
  lines.push('}');
  return lines.join('\n');
}

/* ================== Group & render ================== */
function groupByYear(entries){
  const map = new Map();
  for(const e of entries){
    const y = yearOf(e) || 0;
    if(!map.has(y)) map.set(y, []);
    map.get(y).push(e);
  }
  const years = Array.from(map.keys()).sort((a,b)=>{
    if(a===0) return 1;
    if(b===0) return -1;
    return b - a;
  });
  return {map, years};
}
function renderList(entries){
  const out = $('output');
  out.innerHTML='';
  const {map, years} = groupByYear(entries);
  for(const y of years){
    const groupLi = document.createElement('li');
    groupLi.className = 'group';
    groupLi.textContent = (y===0? 'No year' : String(y));
    out.appendChild(groupLi);

    const arr = map.get(y).slice().sort((a,b)=> descendingDateScore(b) - descendingDateScore(a));
    for(const e of arr){
      const li = document.createElement('li');
      renderItem(li, e);
      out.appendChild(li);
    }
  }
}

/* ================== Filter pipe ================== */
function applyFilters(all){
  const nameVal = $('f-name').value.trim();
  const titleVal = $('f-title').value.trim().toLowerCase();

  let entries = all.slice();
  if(nameVal){ entries = entries.filter(e => peopleListMatchesEntry(e, nameVal)); }
  if(titleVal){
    entries = entries.filter(e => {
      const t = (e.fields||{}).title || '';
      return stripBraces(unlatex(t)).toLowerCase().includes(titleVal);
    });
  }
  renderList(entries);

  const total = all.length;
  const shown = entries.length;
  const filt = [];
  if(nameVal)  filt.push('name="'+escHtml(nameVal)+'"');
  if(titleVal) filt.push('title="'+escHtml(titleVal)+'"');
  setStatus(`Loaded ${total} entries — showing ${shown}` + (filt.length? ` (filters: ${filt.join(', ')})` : ' (no filters)'));
}

/* ================== Main ================== */
(async function(){
  // Optional fragment injection
  const navUrl  = getParam('nav');
  const headUrl = getParam('head');
  const footUrl = getParam('foot');
  if(navUrl)  await injectHtmlFrom(navUrl,  'navslot');
  if(headUrl) await injectHtmlFrom(headUrl, 'headslot');

  setStatus('Loading .bib files …');
  const texts = await fetchAllBibFiles(bibFiles);

  const all = [];
  for(const {file, text} of texts){
    const parsed = parseBibtex(text).map(e => { e._src=file; return e; });
    all.push(...parsed);
  }
  const dataset = dedupeByKey(all);

  // Wire filters
  const fName  = $('f-name');
  const fTitle = $('f-title');
  fName.addEventListener('input', ()=>applyFilters(dataset));
  fTitle.addEventListener('input', ()=>applyFilters(dataset));
  document.querySelectorAll('.clear-btn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const id = btn.getAttribute('data-target');
      const el = $(id);
      if(el){ el.value=''; el.dispatchEvent(new Event('input', {bubbles:true})); el.focus(); }
    });
  });
  $('btn-reset').addEventListener('click', ()=>{
    fName.value=''; fTitle.value=''; applyFilters(dataset);
  });

  // Start with URL params if provided, else empty
  const initName  = getParam('name');
  const initTitle = getParam('title');
  if (initName)  fName.value  = initName;
  if (initTitle) fTitle.value = initTitle;
  applyFilters(dataset);

  // Optional foot injection (after content)
  if(footUrl) await injectHtmlFrom(footUrl, 'footslot');

  // Footer "Updated:" date from latest Last-Modified among fetched bibs (fallback to today)
  const updatedEl = $('updated');
  try{
    let latest = null;
    if(lastModified.length){
      latest = new Date(Math.max(...lastModified.map(d => d.getTime())));
    }
    if(!latest || isNaN(latest.getTime())) latest = new Date();
    const yyyy = latest.getFullYear();
    const mm = String(latest.getMonth()+1).padStart(2,'0');
    const dd = String(latest.getDate()).padStart(2,'0');
    if(updatedEl) updatedEl.textContent = `Updated: ${yyyy}-${mm}-${dd}`;
  }catch(_){
    if(updatedEl){ const d=new Date(); updatedEl.textContent = `Updated: ${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
  }
})();
</script>
</body>
</html>