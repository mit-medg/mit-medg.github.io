<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <title>MEDG Publications</title>

  <!-- Match uploaded nav fonts -->
  <link href="https://fonts.googleapis.com/css?family=Crimson+Text:300italic,400italic|Roboto:300,400,300italic,400italic" rel="stylesheet">
  <style>
    :root { --fg:#0f172a; --muted:#475569; --bg:#f8fafc; --card:#ffffff; }
    * { box-sizing: border-box; }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--fg);
      font-family:'Source Sans Pro','Helvetica Neue',Helvetica,Arial,sans-serif; }

    /* Navigation (identical to your working style) */
    #header {
      position: sticky; top: 0; z-index: 50;
      display:flex; align-items:center; justify-content:space-between;
      background: rgba(248,250,252,.92);
      backdrop-filter: saturate(180%) blur(6px);
      border-bottom: 1px solid #e2e8f0; padding: 12px 18px;
    }
    #header h1, #header h1 a {
      margin:0; font-family:'Roboto','Helvetica Neue',Helvetica,Arial,sans-serif;
      font-weight:300; text-transform:uppercase; letter-spacing:normal;
      font-size:1.1em; color:navy; text-decoration:none;
    }
    #nav ul { list-style:none; display:flex; gap:22px; margin:0; padding:0; flex-wrap:wrap; }
    #nav a {
      display:inline-block; padding:6px 8px; border:none;
      color:#8a8f98; text-decoration:none;
      font-family:'Roboto','Helvetica Neue',Helvetica,Arial,sans-serif;
      font-weight:300; text-transform:uppercase; letter-spacing:normal; font-size:1em;
      background:transparent;
    }
    #nav a:hover { color:#2e2e2e; }

    main { max-width: 1000px; margin: 24px auto; padding: 0 18px 48px; }
    .card { background:#fff; border:1px solid #e2e8f0; border-radius:16px;
      box-shadow:0 2px 10px rgba(2,6,23,.06); padding:18px; }

    .filters {
      display:grid; grid-template-columns:repeat(auto-fit, minmax(220px,1fr));
      gap:8px; margin-bottom:8px; width:100%;
    }
    .filters .field { display:flex; flex-direction:column; gap:4px; position:relative; min-width:0; }
    .filters label { font-size:.8rem; color:var(--muted); }
    .filters input {
      border:1px solid #cbd5e1; border-radius:10px; padding:8px 28px 8px 10px; font-size:.95rem; width:100%;
    }
    .clear-btn { position:absolute; right:8px; top:50%; transform:translateY(-50%);
      cursor:pointer; font-weight:700; color:red; font-size:1rem; display:none; user-select:none; }
    .field input:not(:placeholder-shown)+.clear-btn { display:block; }

    #output { counter-reset:item; list-style:none; padding-left:0; }
    #output li {
      counter-increment:item; background:#fff; border:1px solid #e2e8f0; border-radius:10px;
      padding:4px 6px; margin:2px 0;
    }
    #output li::before {
  content: counter(item) ". ";
  font-weight: 400;   /* or 'normal' */
  margin-right: 6px;
}
    #output li.group {
      counter-increment:none; background:transparent; border:none; padding:0; margin:10px 0 2px;
      font-weight:700; font-size:1.05rem;
    }
    #output li.group::before { content:''; margin:0; }

    .small{font-size:.9rem}
    .error{background:#fef2f2;border:1px solid
    #fecaca;color:#991b1b;padding:6px
10px;border-radius:8px;margin-top:8px}
/* [bib] toggle + inline bib block */
.bib-btn{
  margin-left:6px;
  padding:0 6px;
  font: inherit;
  font-size:.85em;
  color:#444;
  background:transparent;
  border:1px solid #cbd5e1;
  border-radius:6px;
  cursor:pointer;
}
.bib-btn:hover{ background:#f1f5f9; }
.bib-block{
  white-space:pre-wrap;
  background:#f8fafc;
  border:1px solid #e2e8f0;
  border-radius:8px;
  padding:8px;
  margin-top:6px;
  font-size:.85rem;
}
  </style>
</head>
<body>
  <header id="header">
    <h1><strong><a href="index.html">MIT CSAIL MEDG</a></strong></h1>
    <nav id="nav">
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="people.html">People</a></li>
        <li><a href="https://www.csail.mit.edu/research/clinical-decision-making-group#projects" target="_blank">Projects</a></li>
        <li><a href="publications.html">Publications</a></li>
        <li><a href="blogs.html">Blogs</a></li>
        <li><a href="seminars.html">Seminars</a></li>
        <li><a href="faq.html">FAQs</a></li>
        <li><a href="https://groups.csail.mit.edu/medg/index_archive.html" target="_blank">Archive</a></li>
      </ul>
    </nav>
  </header>

  <main>
    <div class="card">
      <div id="filters" class="filters">
        <div class="field">
          <label for="f-name">Name</label>
          <input id="f-name" type="text" placeholder="e.g., Patil"/>
          <span class="clear-btn" data-target="f-name">☒</span>
        </div>
        <div class="field">
          <label for="f-title">Title</label>
          <input id="f-title" type="text" placeholder="e.g., learning"/>
          <span class="clear-btn" data-target="f-title">☒</span>
        </div>
      </div>
      <div id="status" class="small muted" style="margin-top:10px"></div>
      <div id="err" class="error" style="display:none"></div>
    </div>

    <ol id="output"></ol>
  </main>

  <script>
    /* ---------- Elements & utilities ---------- */
    const statusEl=document.getElementById('status'),
          errorEl=document.getElementById('err'),
          outputEl=document.getElementById('output'),
          filtersEl=document.getElementById('filters');
    const inName=()=>document.getElementById('f-name'),
    inTitle=()=>document.getElementById('f-title');
    let entryByKey = new Map();

    function status(h){ if(statusEl) statusEl.innerHTML = h; }
    function showError(e){
      if(!errorEl) return;
      errorEl.style.display='block';
      const m=(e&&e.message)?e.message:String(e);
      errorEl.innerHTML = '⚠️ ' + escapeHtml(m) +
        '<div class="small">Tip: If this page is opened via <code>file:///</code>, browsers block <code>fetch</code>. Serve locally (e.g., <code>python3 -m http.server</code>).</div>';
      console.error(e);
    }

    /* ---------- Which bib files to load (publications only) ---------- */
    const bibFiles = [
      "bib/psz.bib","bib/medg.bib","bib/emily.bib","bib/jindi.bib",
      "bib/mmd.bib","bib/ckbjimmy.bib","bib/stmharry.bib","bib/symin95.bib",
      "bib/gupta.bib","bib/wjl.bib"
    ];

    /* ---------- URL filters (optional) ---------- */
    function getFilters(){
      try{
        const p=new URLSearchParams(window.location.search);
        const g=v=>v&&v.trim()?v.trim():'';
        return { name:g(p.get('name')), title:g(p.get('title')) };
      }catch{
        return { name:'', title:'' };
      }
    }

    let currentEntries=[], allEntries=[], filtersInitialized=false, initialUrlFilters={name:'',title:''};

    window.addEventListener('DOMContentLoaded', ()=>{
      initialUrlFilters=getFilters();
      setupLiveFilters();
      loadAll().catch(showError);
      // Clear buttons
      document.querySelectorAll('.clear-btn').forEach(btn=>{
        btn.addEventListener('click',()=>{
          const id=btn.getAttribute('data-target');
          const inp=document.getElementById(id);
          if(inp){
            inp.value='';
            inp.dispatchEvent(new Event('input',{bubbles:true}));
            inp.dispatchEvent(new Event('change',{bubbles:true}));
          }
        });
      });
    });

    /* ---------- Load & parse ---------- */
    async function loadAll(){
      status('Fetching bib files…');
      if(errorEl) errorEl.style.display='none';
      let entries=[], failed=[];

      for(const f of bibFiles){
        try{
          const res = await fetch(f,{cache:'no-store'});
          if(!res.ok) throw new Error('HTTP ' + res.status);
          const txt = await res.text();
          const parsed = parseBibtex(txt);
          parsed.forEach(e=>e._file=f);
          entries = entries.concat(parsed);
        }catch(e){
          failed.push({file:f,error:e.message||String(e)});
        }
      }

      // Deduplicate by key
      const map=new Map();
      for(const e of entries){
        const k=String(e.key||'').toLowerCase();
        if(!k) continue;
        if(!map.has(k)) map.set(k,e);
      }
      entries = Array.from(map.values());

      // Keep NON-theses on this page
      entries = entries.filter(e => !/^(phdthesis|mastersthesis|thesis)$/i.test(e.type));
// Build lookup for [bib] toggles
entryByKey = new Map(entries.map(e => [String(e.key||'').toLowerCase(), e]));

      allEntries = entries;
      const live = {
        name:  inName()?.value?.trim()  || initialUrlFilters.name  || '',
        title: inTitle()?.value?.trim() || initialUrlFilters.title || ''
      };
      const filtered = applyFilters(entries, live);
      currentEntries = filtered;

      let msg = '<strong>' + filtered.length + '</strong> entries shown';
      if (failed.length) {
        const parts = failed.map(f => escapeHtml(f.file) + ' (' + escapeHtml(f.error) + ')').join('; ');
        msg += '<div class="small" style="color:#991b1b">Failed: ' + parts + '</div>';
      }
      status(msg);

      renderPublications(filtered);
    }

    /* ---------- Live filters ---------- */
    function setupLiveFilters(){
      if(!filtersEl) return;
      const fName=inName();  if(fName)  fName.value  = initialUrlFilters.name  || '';
      const fTitle=inTitle();if(fTitle) fTitle.value = initialUrlFilters.title || '';

      if(!filtersInitialized){
        const handler=()=>{
          const live = {
            name:  inName()?.value?.trim()  || '',
            title: inTitle()?.value?.trim() || ''
          };
          const filtered = applyFilters(allEntries, live);
          currentEntries = filtered;
          let msg = '<strong>' + filtered.length + '</strong> entries shown';
          if(live.name)  msg += ' — name: <code>'  + escapeHtml(live.name)  + '</code>';
          if(live.title) msg += ' — title: <code>' + escapeHtml(live.title) + '</code>';
          status(msg);
          renderPublications(filtered);
        };
        ['input','keyup','change'].forEach(evt=>filtersEl.addEventListener(evt, handler));
        requestAnimationFrame(handler);
        filtersInitialized=true;
      }
    }

    function applyFilters(entries,{name='',title=''}={}){
      if(!(name||title)) return entries.slice();
      const n=name.toLowerCase(), t=title.toLowerCase();
      return entries.filter(e=>{
        const nameStr=(renderNamesForFilter(e)||'').toLowerCase();
        const titleStr=((e.fields&&e.fields.title)?e.fields.title:'').replace(/[{}]/g,'').toLowerCase();
        return (name?nameStr.includes(n):true) && (title?titleStr.includes(t):true);
      });
    }

    /* ---------- Render (group by year desc) ---------- */
    function renderPublications(entries){
      const dated=new Map(), unknown=[];
      for(const e of entries){
        const y=parseInt(e.fields && e.fields.year ? e.fields.year : '0',10) || 0;
        if(y>0){
          const k=String(y);
          if(!dated.has(k)) dated.set(k,[]);
          dated.get(k).push(e);
        }else{
          unknown.push(e);
        }
      }
      const years = Array.from(dated.keys())
        .map(x=>parseInt(x,10))
        .filter(n=>!Number.isNaN(n)&&n>0)
        .sort((a,b)=>b-a);

      const tb=(a,b)=>{
        const d = dateScore(b) - dateScore(a);
        if(d!==0) return d;
        const ak = firstAuthorKey(a).localeCompare(firstAuthorKey(b));
        if(ak!==0) return ak;
        const t = (a.fields.title||'').localeCompare(b.fields.title||'');
        if(t!==0) return t;
        return (a.key||'').localeCompare(b.key||'');
      };

      outputEl.innerHTML = '';
      const addHeader = label => {
        const h=document.createElement('li');
        h.className='group';
        h.textContent=label;
        outputEl.appendChild(h);
      };
      const addItem = e => {
        const li=document.createElement('li');
        li.innerHTML = formatVancouver(e);
        outputEl.appendChild(li);
      };

      for (const y of years) {
        addHeader(String(y));
        dated.get(String(y)).sort(tb).forEach(addItem);
      }
      if (unknown.length) {
        addHeader('Unknown year');
        unknown.sort(tb).forEach(addItem);
      }
      if (!years.length && !unknown.length) {
        status('0 entries matched. Possible reasons: (1) the .bib files failed to load, (2) all entries are theses (this page excludes theses), or (3) your filters hid them.');
      }
    }

    /* ---------- Vancouver + helpers ---------- */
    function formatVancouver(entry){
      const f = entry.fields || {};
      const isThesis = /^(phdthesis|mastersthesis|thesis)$/i.test(entry.type);
      const strip = s => (s||'').replace(/[{}]/g,'');

      // People (initials for non-thesis)
      let people='';
      if(f.author && f.author.trim()){
        people = isThesis ? formatAuthors(strip(f.author), {abbr:false, full:true})
                          : formatAuthors(strip(f.author), {abbr:true});
      }else if(f.editor && f.editor.trim()){
        const raw = strip(f.editor);
        let ed  = (isThesis ? formatAuthors(raw,{abbr:false,full:true})
                            : formatAuthors(raw,{abbr:true})).replace(/[.]\s*$/,'');
        const cnt = (raw||'').split(/\s+and\s+/i).map(s=>s.trim()).filter(Boolean).length;
        people = ed + (cnt>1 ? ' (editors).' : ' (editor).');
      }

      // Title (link to URL or DOI)
      const rawTitle = (f.title||'').trim();
      const cleanTitle = unlatex(rawTitle.replace(/[{}]/g,''));
      const title = ensurePeriod(cleanTitle).trim();
      const doiClean = cleanDoi(f.doi||''); if(doiClean) f.doi = doiClean;
      const link = (f.url && f.url.trim()) ? f.url.trim() : (doiClean ? ('https://doi.org/'+doiClean) : '');

      // Container / base (journal | proceedings | publisher) OR special cases
      const baseRaw = (entry.type==='techreport' ? (f.institution||'') : (f.journal||f.booktitle||f.publisher||''));
      const base = unlatex((baseRaw||'').replace(/[{}]/g,'').trim());

      // Date & details
      const year  = (f.year||'').trim();
      const volume= (f.volume||'').trim();
      const number= (f.number||f.issue||'').trim();
      const pages = (f.pages||'').replace(/--/g,'-').trim();

      let line=''; if(people) line += people + ' ';
      if(title){
        line += link
          ? '<a href="' + escapeAttr(link) + '" target="_blank" rel="noopener noreferrer"><strong>' + escapeHtml(title) + '</strong></a> '
          : '<strong>' + escapeHtml(title) + '</strong> ';
      }

      // Inbook adds bookauthor/editor; techreport adds type/number and uses institution
      (function(){
        let prefix='', mid='', container=base;
        if(entry.type==='inbook'){
          const ba = strip(f.bookauthor);
          if(ba && ba.trim()){
            prefix = formatAuthors(ba,{abbr:true});
            prefix = prefix.replace(/\.$/,'') + ', ';
          } else if(f.editor && f.editor.trim()){
            const raw = strip(f.editor);
            let ed = formatAuthors(raw,{abbr:true});
            ed = ed.replace(/\.$/,'');
            const cnt=(raw||'').split(/\s+and\s+/i).map(s=>s.trim()).filter(Boolean).length;
            prefix = ed + (cnt>1?' (editors),':' (editor),') + ' ';
          }
        }
        if(entry.type==='techreport'){
          const repType = unlatex((f.type||'Technical Report').replace(/[{}]/g,'').trim());
          const repNum  = ((f.number||f.reportnumber||'')+'').trim();
          if(repType||repNum) mid = escapeHtml(repType) + (repNum?(' ' + escapeHtml(repNum)):'') + '. ';
          const inst = (f.institution||'').replace(/[{}]/g,'').trim();
          if(inst) container = inst;
        }
        const cont = container ? '<em>' + escapeHtml(container) + '</em> ' : '';
        if(prefix || mid || cont) line += (prefix + mid + cont);
      })();

      // Tail: year; volume(issue):pages.
      const tail=[]; if(year) tail.push(year);
      if(volume){ let v=volume; if(number) v += '(' + number + ')'; tail.push(v); }
      if(pages) tail.push(pages.replace(/^p\.?\s*/i,''));
      if(tail.length){
        const y=tail.shift(); const rest=tail.join(':');
        line += (rest ? (y + ';' + rest + '. ') : (y + '. '));
      }

  // Add [bib] toggle button (uses lowercase key for lookup)
  if (entry.key) {
    line += ' <button class="bib-btn" data-key="' + String(entry.key).toLowerCase() + '">[bib]</button>';
  }
return line.trim();

      return line.trim();
    }

    function renderNamesForFilter(entry){
      const f=entry.fields||{}; const strip=s=>(s||'').replace(/[{}]/g,'');
      if(f.author&&f.author.trim()) return formatAuthors(strip(f.author),{abbr:true}).replace(/[.]\s*$/,'');
      if(f.editor&&f.editor.trim()) return formatAuthors(strip(f.editor),{abbr:true}).replace(/[.]\s*$/,'');
      return '';
    }
    function ensurePeriod(s){ s=s.trim(); if(!s) return s; return /[.!?]\s*$/.test(s) ? s : (s + '.'); }

    // Authors: initials (non-thesis); theses handled elsewhere
    function formatAuthors(field,{abbr=true,full=false}={}){
      if(!field) return '';
      const parts = field.split(/\s+and\s+/i).map(s=>s.trim()).filter(Boolean);
      const names = parts.map(fmtOne);
      const list  = names.join(', ');
      return list ? list + '.' : '';
      function fmtOne(name){
        const clean=(name||'').replace(/[{}]/g,'').trim();
        if(clean.includes(',')){ // "Last, Given"
          const pair=clean.split(',');
          const last=(pair[0]||'').trim(), givenRaw=(pair[1]||'').trim();
          if(full) return (unlatex(givenRaw) + ' ' + unlatex(last)).replace(/\s+/g,' ').trim();
          const init=givenToInitials(givenRaw,abbr);
          return init ? (unlatex(last) + ' ' + init) : unlatex(last);
        }else{ // "Given Last"
          const bits=clean.split(/\s+/).filter(Boolean);
          if(bits.length===1) return unlatex(bits[0]);
          const last=bits.pop(), given=bits.join(' ');
          if(full) return (unlatex(given) + ' ' + unlatex(last)).replace(/\s+/g,' ').trim();
          const init=givenToInitials(given,abbr);
          return init ? (unlatex(last) + ' ' + init) : unlatex(last);
        }
      }
    }
    function givenToInitials(given,abbr){
      if(!given) return '';
      const letters = given
        .replace(/\([^)]*\)/g,'')
        .replace(/\{[^}]*\}/g,'')
        .split(/[-\s]+/).filter(Boolean)
        .map(w=> w[0] ? w[0].toUpperCase() : '')
        .join(abbr?'':' ');
      return letters;
    }

    function unlatex(s){ return String(s||'').replace(/\\&/g,'&'); } // \& → & (will render as &amp; in HTML)
    function escapeHtml(s){ return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
    function escapeAttr(s){ return String(s).replaceAll('"','&quot;'); }
    function cleanDoi(s){
      if(!s) return '';
      let x = String(s).trim();
      x = x.replace(/^doi:\s*/i,'');                         // "doi:" + optional spaces
      x = x.replace(/^https?:\/\/(dx\.)?doi\.org\//i,'');    // strip full DOI URL
      x = x.replace(/\s+/g,'');                              // remove whitespace
      x = x.replace(/[<>]/g,'');                             // strip angle brackets
      x = x.replace(/\.$/,'');                               // trailing period
      return x;
    }

function buildBibtex(entry){
  const type = (entry.type || 'misc');
  const key  = (entry.key  || 'key');
  const f    = entry.fields || {};

  // Exclude unwanted fields (case-insensitive)
    // Exclude unwanted fields (case-insensitive)
  const skip = /^(file|date-added|date-modified|bdsk-url)/i;

  // Sort fields alphabetically for stable output
  const fields = Object.keys(f)
    .filter(k => k && !skip.test(k))
    .sort((a,b)=> a.localeCompare(b));

  // Re-wrap values in braces; use original field text (we never unlatex in storage)
  const lines = fields.map(k => {
    // keep original spacing minimal; preserve internal LaTeX and braces as parsed
    const v = String(f[k] == null ? '' : f[k]).trim();
    return `  ${k} = {${v}}`;
  });

  // Commas after each field; trailing comma optional but accepted by BibTeX
  return `@${type}{${key},\n${lines.join(',\n')}\n}`;
}

    function firstAuthorKey(entry){
      const base=(entry.fields && entry.fields.author && entry.fields.author.trim()) ? entry.fields.author : (entry.fields.editor||'');
      const a=(base||'').split(/\s+and\s+/i)[0]||'';
      return a.replace(/[{}]/g,'').replace(/[^a-zA-Z,\s-]/g,'').toLowerCase();
    }
    function dateScore(e){
      const y=parseInt(e.fields && e.fields.year ? e.fields.year : '0',10) || 0;
      let m=e.fields && e.fields.month ? e.fields.month : '0';
      const mm={jan:1,feb:2,mar:3,apr:4,may:5,jun:6,jul:7,aug:8,sep:9,oct:10,nov:11,dec:12};
      m = (mm[String(m).slice(0,3).toLowerCase()] || parseInt(m,10) || 0);
      const d=parseInt(e.fields && e.fields.day ? e.fields.day : '0',10) || 0;
      return y*10000 + m*100 + d;
    }

    /* ---------- BibTeX parsing ---------- */
    function parseBibtex(text){
      text = text.replace(/^\s*%.*$/gm,''); // strip comment lines
      const out=[]; const rx=/@([a-zA-Z]+)\s*\{\s*([^,]+)\s*,([\s\S]*?)\}\s*(?=@|$)/g; let m;
      while((m=rx.exec(text))){
        const type=(m[1]||'').toLowerCase();
        const key=(m[2]||'').trim();
        const body=(m[3]||'');
        out.push({type,key,fields:parseFields(body)});
      }
      return out;
    }
    function parseFields(body){
      const out={}; let i=0, t='', depth=0, inQ=false; const parts=[];
      while(i<body.length){
        const c=body[i];
        if(c=='"' && body[i-1] !== "\\"){ inQ=!inQ; t+=c; i++; continue; }
        if(c=='{' && !inQ){ depth++; t+=c; i++; continue; }
        if(c=='}' && !inQ && depth>0){ depth--; t+=c; i++; continue; }
        if(c==',' && !inQ && depth===0){ parts.push(t); t=''; i++; continue; }
        t+=c; i++;
      }
      if(t.trim()) parts.push(t);
      for(const p of parts){
        const kv=p.split(/\s*=\s*/);
        if(kv.length<2) continue;
        const k=kv.shift().trim().toLowerCase();
        const v=kv.join('=').trim();
        out[k]=unbrace(unquote(v)).replace(/\s+/g,' ').trim();
      }
      return out;
}

    function unquote(s){ if((s.startsWith('"')&&s.endsWith('"'))||(s.startsWith("'")&&s.endsWith("'"))) return s.slice(1,-1); return s; }
    function unbrace(s){
      let changed=true;
      while(changed){
        changed=false;
        if(s.startsWith('{')&&s.endsWith('}')){
          let d=0,ok=true;
          for(let i=0;i<s.length;i++){ const c=s[i]; if(c=='{') d++; if(c=='}') d--; if(d===0&&i<s.length-1){ ok=false; break; } }
          if(ok){ s=s.slice(1,-1); changed=true; }
        }
      }
      return s;
    }

// Toggle inline BibTeX on [bib] button click (event delegation)
document.addEventListener('click', function(ev){
  const btn = ev.target.closest('.bib-btn');
  if(!btn) return;
  const li = btn.closest('li');
  if(!li) return;

  // If already open, close it
  const open = li.querySelector('.bib-block');
  if(open){ open.remove(); return; }

  // Otherwise build and show
  const key = (btn.getAttribute('data-key') || '').toLowerCase();
  const entry = entryByKey.get(key);
  if(!entry) return;

  const pre = document.createElement('pre');
  pre.className = 'bib-block';
  pre.textContent = buildBibtex(entry);  // textContent to avoid HTML escaping
  li.appendChild(pre);
});

  </script>
</body>
</html>